# Implementation Plan: Follow-Up Pills (Two-Call Approach)

**Date:** January 15, 2026  
**Status:** Planning  
**Priority:** High - Enhances user engagement and conversation flow

---

## Objective

Implement AI-generated follow-up pills that appear directly below each assistant message. These pills are dynamically generated based on the specific message content and provide natural conversation continuations. The implementation uses a two-call approach: first call streams the main response, second call generates structured follow-up pills using JSON mode for reliability.

---

## Acceptance Criteria

1. ✅ **Follow-up pills appear below assistant messages** - Pills render inline below message content, before source attribution
2. ✅ **Pills are AI-generated** - Each assistant message gets 2-4 unique follow-up questions generated by GPT-4o
3. ✅ **Pills prefills input** - Clicking a pill prefills the chat input (does not send immediately)
4. ✅ **Pills persist** - Follow-up pills remain visible for all assistant messages (not just most recent)
5. ✅ **Visual consistency** - Pills use same design system as suggested pills (like "What is the best way to attack?") - secondaryAccent color with border
6. ✅ **Reliable generation** - JSON mode ensures consistent structured output (no parsing failures)
7. ✅ **Graceful degradation** - If pill generation fails, message still displays (no breaking errors)
8. ✅ **Performance** - Second API call adds ~500ms-1s latency after streaming completes (non-blocking - user already sees response, pills appear smoothly via stream event)
9. ✅ **Event logging** - Clicking a follow-up pill logs an event to Event table with pill text in metadata

---

## Clarifying Questions

**All questions answered by user:**
1. ✅ **Click behavior:** Prefill input (not send immediately)
2. ✅ **Persistence:** Show pills for all assistant messages (not just most recent)
3. ✅ **Visual style:** Prominent, similar to expansion/helpful pills
4. ✅ **Position:** Below message text, before source attribution

---

## Assumptions Gate

**Proceeding with assumptions:**
- User wants pills to appear inline below messages (not in pills area)
- Two-call approach is acceptable (adds ~500ms-1s latency)
- JSON mode will be used for structured output (reliability over single-call)
- Pills will be stored in a separate `followUpPills String[]` field on Message model - cleaner separation from RAG context
- Frontend will handle pill display and click handling
- Feature **enabled by default**, can be disabled per chatbot via `chatbot.configJson.enableFollowUpPills: false`
- Custom prompts stored in `chatbot.configJson.followUpPillsPrompt` (optional, uses default if not set)

**Proceed with assumptions?** ✅ **Yes** - All assumptions validated by user

---

## Minimal Approach

**Smallest viable implementation:**

1. **Backend:** Add second OpenAI API call after streaming completes to generate follow-up pills
2. **Data:** Store pills in separate `followUpPills` field (String[]) - cleaner separation from RAG context
3. **Schema:** Add `followUpPills String[]` field to Message model (migration required)
4. **Frontend:** Create new component to display follow-up pills below messages
5. **Integration:** Wire pills to input prefill functionality

**Why this is minimal:**
- Clean separation: Pills are UI elements, not RAG context (context field is for RAG chunks/metadata)
- Better type safety: String[] field is more explicit than JSON nested structure
- Easier querying: Can query messages with pills separately if needed
- Leverages existing pill design system
- Minimal changes to chat flow
- Feature **enabled by default**, can be disabled per chatbot with `configJson.enableFollowUpPills: false`
- **Store once approach**: Generate pills first, then store message with complete data (simpler than storing twice and updating)

**Why separate field instead of message.context:**
- **Separation of concerns**: `context` field is for RAG metadata (chunks, retrieval info), pills are UI elements
- **Type safety**: String[] field provides better type checking than JSON nested structure
- **Queryability**: Easier to query messages with pills if needed for analytics
- **Clarity**: Makes it explicit that pills are a first-class feature, not RAG metadata

**Why "store once" instead of "update":**

**Option A: Store Once (CHOSEN)**
- Generate pills first (after streaming completes)
- Store message once with complete data (chunks in context field + pills in followUpPills field)
- **Pros:** Single DB write, atomic, simpler code, no merge logic
- **Cons:** Slight delay before message appears in DB (pills generation adds ~500ms-1s)

**Option B: Store Then Update**
- Store message immediately after streaming (with chunks only)
- Generate pills
- Update message with pills in context
- **Pros:** Message appears in DB immediately
- **Cons:** Two DB writes, need merge logic, more complex error handling

**Decision:** Choose Option A (store once) because:
- Pills are optional enhancement - slight delay is acceptable
- Simpler code is more maintainable
- Single atomic write is more reliable
- User already sees the response (streaming), so DB delay doesn't affect UX

---

## Text Diagram

### Current Flow
```
User sends message
  ↓
API: Stream response (OpenAI)
  ↓
Frontend: Display streaming text
  ↓
API: Store message + context
  ↓
Frontend: Show pills area (feedback/expansion/general)
```

### New Flow
```
User sends message
  ↓
API: Stream response (OpenAI) ──┐
  ↓                              │
Frontend: Display streaming text │
  ↓                              │
API: Generate follow-up pills (OpenAI JSON mode) ←┘
  ↓
API: Store message ONCE with complete data (chunks in context + pills in followUpPills field)
  ↓
API: Send pills via structured prefix __PILLS__{...} (after message created)
  ↓
Frontend: Parse pills from structured prefix using indexOf/substring (no regex, no flicker)
  ↓
Frontend: Display pills below message
  ↓
User clicks pill → Prefill input + Log event
```

### Component Structure
```
Message Component
├── Message Content (markdown)
├── Follow-Up Pills Component ← NEW
│   ├── Pill 1: "Tell me more about..."
│   ├── Pill 2: "Give examples of..."
│   └── Pill 3: "How would I use..."
└── Source Attribution
```

---

## Plan File Contents

### 1. Backend Changes

#### 1.1 Create Follow-Up Pills Generation Module

**File:** `lib/follow-up-pills/generate-pills.ts` (NEW)

**Purpose:** Extract pill generation logic into a dedicated module (better separation of concerns, avoids bloating chat route)

**Exports:**
```typescript
export interface GeneratePillsOptions {
  assistantResponse: string;
  configJson: Record<string, any> | null;
  chatbotId: string;
  conversationId: string;
}

export interface GeneratePillsResult {
  pills: string[];
  generationTimeMs: number;
  error?: string;
}

export async function generateFollowUpPills(
  options: GeneratePillsOptions
): Promise<GeneratePillsResult>
```

**Implementation:**
```typescript
import OpenAI from 'openai';
import { getOpenAIClient } from '@/lib/openai/client';

const DEFAULT_PILLS_PROMPT = `Based on the assistant's response above, generate 2-4 follow-up questions that naturally continue the conversation. Return ONLY a JSON object with this exact structure: {"followUps": ["question 1", "question 2", "question 3"]}. Each question should be 5-15 words, natural and conversational, directly related to the assistant's response, and actionable.`;

const PILLS_SYSTEM_PROMPT = `You are a helpful assistant that generates context follow-up questions based on conversation responses. Generate questions that are natural, conversational, and help users continue the conversation.`;

export interface GeneratePillsOptions {
  assistantResponse: string;
  configJson: Record<string, any> | null;
  chatbotId: string;
  conversationId: string;
}

export interface GeneratePillsResult {
  pills: string[];
  generationTimeMs: number;
  error?: string;
}

export async function generateFollowUpPills(
  options: GeneratePillsOptions
): Promise<GeneratePillsResult> {
  const { assistantResponse, configJson, chatbotId, conversationId } = options;
  const startTime = Date.now();
  
  // Check if feature is disabled (enabled by default)
  const isFeatureDisabled = configJson?.enableFollowUpPills === false;
  
  if (isFeatureDisabled) {
    return {
      pills: [],
      generationTimeMs: 0,
    };
  }
  
  try {
    // Get chatbot-specific follow-up pills prompt from configJson
    const customPillsPrompt = configJson?.followUpPillsPrompt;
    
    // Use custom prompt if provided, otherwise use default
    const pillsPrompt = (customPillsPrompt && customPillsPrompt.trim() !== '') 
      ? customPillsPrompt 
      : DEFAULT_PILLS_PROMPT;
    
    const openai = getOpenAIClient();
    
    const pillsResponse = await openai.chat.completions.create({
      model: 'gpt-4o',
      messages: [
        { role: 'system', content: PILLS_SYSTEM_PROMPT },
        // Only use the assistant's latest response (not full conversation history)
        { role: 'assistant', content: assistantResponse },
        { role: 'user', content: pillsPrompt },
      ],
      response_format: { type: 'json_object' },
      temperature: 0.8,
    });

    const pillsData = JSON.parse(pillsResponse.choices[0].message.content || '{}');
    const pills = Array.isArray(pillsData.followUps) ? pillsData.followUps : [];
    
    const generationTime = Date.now() - startTime;
    console.log(`Follow-up pills generated in ${generationTime}ms: ${pills.length} pills`);
    
    return {
      pills,
      generationTimeMs: generationTime,
    };
  } catch (error) {
    const generationTime = Date.now() - startTime;
    console.error('Error generating follow-up pills:', error);
    console.error('Pill generation error details:', {
      error: error instanceof Error ? error.message : String(error),
      chatbotId,
      conversationId,
      responseLength: assistantResponse.length,
    });
    
    return {
      pills: [],
      generationTimeMs: generationTime,
      error: error instanceof Error ? error.message : String(error),
    };
  }
}
```

**Benefits:**
- **Separation of concerns**: Pill generation logic isolated from chat route
- **Testability**: Module can be unit tested independently
- **Reusability**: Can be used by other routes if needed
- **Maintainability**: Easier to modify pill generation without touching chat route
- **File size**: Keeps chat route from growing further (already 768 lines)

#### 1.2 Update Chat API Route (`app/api/chat/route.ts`)

**Location:** After streaming completes (around line 522)

**Changes:**
- Import `generateFollowUpPills` from new module
- Call module function after streaming completes
- Store assistant message ONCE with complete data (chunks in context field + pills in followUpPills field)
- Send pills via structured prefix `__PILLS__{...}` after message creation (no regex needed)

**Implementation:**
```typescript
import { generateFollowUpPills } from '@/lib/follow-up-pills/generate-pills';

// After streaming completes (line 522)
// Generate follow-up pills first, then store message once with complete data
const pillsResult = await generateFollowUpPills({
  assistantResponse: fullResponse,
  configJson: chatbot.configJson as Record<string, any> | null,
  chatbotId: chatbot.id,
  conversationId,
});

const followUpPills = pillsResult.pills;

// Store assistant message ONCE with complete data (chunks in context + pills in separate field)
// This is simpler than storing twice and avoids merge logic
const assistantMessage = await prisma.message.create({
  data: {
    conversationId,
    userId: dbUserId,
    role: 'assistant',
    content: fullResponse,
    context: { 
      chunks: chunksForContext,
      // Note: followUpPills NOT stored in context - stored in separate field below
    },
    followUpPills: followUpPills, // Separate field for pills (not in RAG context)
    sourceIds,
  },
});

// Send pills to frontend via structured prefix (no regex needed)
// Send AFTER message creation so we have the messageId
// Format: __PILLS__{json} - easy to parse with indexOf and substring
if (followUpPills.length > 0) {
  const pillsDataJson = JSON.stringify({
    messageId: assistantMessage.id,
    pills: followUpPills,
  });
  controller.enqueue(encoder.encode(`\n\n__PILLS__${pillsDataJson}`));
}
```

**Error Handling:**
- Wrap pill generation in try-catch
- If generation fails, continue with empty array
- Log errors but don't fail the request

**Performance:**
- **Non-blocking**: Second call happens AFTER streaming completes - user already sees response, so pill generation doesn't block UX
- Uses only latest assistant response (efficient, not full conversation)
- JSON mode ensures fast parsing
- Pills sent via structured prefix (`__PILLS__`) in stream (no regex, no separate API call, no flicker)
- Message stored once with complete context (simpler than update approach)
- Generation time logged for monitoring
- **Clarification**: The ~500ms-1s latency occurs AFTER the user sees the response (streaming already complete), so it doesn't impact perceived performance

**Feature Toggle:**
- **Enabled by default**: Pills are generated for all chatbots unless explicitly disabled
- Set `configJson.enableFollowUpPills: false` to disable per chatbot
- If `enableFollowUpPills` is `true`, `null`, or `undefined`, feature is enabled (pills generated)
- Explicit boolean setting provides clear control per chatbot

**Customization:**
- Chatbot-specific prompts stored in `chatbot.configJson.followUpPillsPrompt` (optional)
- If not set or empty string, uses default prompt
- Prompt can include chatbot-specific instructions, tone, or domain-specific guidance
- Example configJson:
  ```json
  {
    "followUpPillsPrompt": "Based on the assistant's response about The Art of War, generate 2-4 strategic follow-up questions that help users apply these principles. Questions should be tactical and practical. Return ONLY JSON: {\"followUps\": [\"question 1\", \"question 2\"]}"
  }
  ```
- To disable feature for specific chatbot:
  ```json
  {
    "enableFollowUpPills": false
  }
  ```

**⚠️ Known Limitation: Missing Creator UI**
- **Current state**: Custom prompts (`followUpPillsPrompt`) and feature toggle (`enableFollowUpPills`) require direct database editing via `configJson` field
- **No UI available**: Creators cannot customize follow-up pill prompts or toggle the feature through the creator dashboard
- **Workaround**: Database/API access required to modify `chatbot.configJson` field
- **Future enhancement**: Add creator dashboard UI for:
  - Toggle follow-up pills on/off per chatbot
  - Customize follow-up pill prompts with rich text editor
  - Preview pill generation examples
- **Acceptable for MVP**: Feature works end-to-end, customization is possible via config, UI can be added in future iteration

#### 1.2 Update Events API Route (`app/api/events/route.ts`)

**Location:** Add 'follow_up_pill_click' to valid event types (around line 87)

**Changes:**
- Add 'follow_up_pill_click' to `validEventTypes` array
- Event metadata structure: `{ pillText: string }`
- messageId FK links to the message the pill belongs to

**Implementation:**
```typescript
// Update validEventTypes array (line 87)
const validEventTypes = [
  'copy', 
  'bookmark', 
  'conversation_pattern', 
  'expansion_followup', 
  'gap_submission',
  'follow_up_pill_click' // ADD: New event type
];
```

**Event Structure:**
- `eventType`: 'follow_up_pill_click'
- `sessionId`: Conversation ID
- `chunkIds`: Array of chunk IDs from message context
- `metadata`: `{ pillText: string, messageId: string }` - The text of the clicked pill AND messageId (Events API extracts messageId from metadata)
- `userId`: Current user ID (if authenticated)

**Important:** The Events API extracts `messageId` from `metadata` and then removes it before storing. So we pass it in metadata, not as a top-level field.

#### 1.3 Schema Migration

**File:** `prisma/schema.prisma`

**Changes:**
- Add `followUpPills String[]` field to Message model
- Field is optional (defaults to empty array)

**Migration:**
```prisma
model Message {
  id             String       @id @default(cuid())
  conversationId String
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  userId         String?
  user           User?        @relation(fields: [userId], references: [id], onDelete: Cascade)
  role           String // 'user' | 'assistant'
  content        String
  context        Json? // { chunks: [{ chunkId, sourceId, text, page?, section? }] }
  followUpPills String[] @default([]) // ADD: Follow-up pills (separate from RAG context)
  sourceIds      String[]     @default([])
  createdAt      DateTime     @default(now())

  // Relations
  bookmarks Bookmark[]
  events    Event[] @relation("EventMessage")

  @@index([conversationId])
  @@index([sourceIds])
  @@index([userId])
}
```

**Type Definitions:**

**Note:** Prisma will auto-generate types. The `Message` type will include `followUpPills: string[]` field.

**Type structure (for reference):**
```typescript
// Message model (Prisma-generated)
interface Message {
  id: string;
  conversationId: string;
  role: string;
  content: string;
  context: Json | null; // { chunks: [...] } - RAG metadata only
  followUpPills: string[]; // Separate field for pills (not in RAG context)
  sourceIds: string[];
  createdAt: Date;
  // ... other fields
}
```

### 2. Frontend Changes

#### 2.1 Create Follow-Up Pills Component

**File:** `components/follow-up-pills.tsx` (NEW)

**Purpose:** Display follow-up pills below assistant messages

**Props:**
```typescript
interface FollowUpPillsProps {
  pills: string[];
  messageId: string;
  conversationId: string;
  chunkIds: string[];
  onPillClick: (pillText: string) => void; // Handles both prefill and event logging
  disabled?: boolean;
}
```

**Implementation:**
- Use existing pill styling system (`getSuggestionPillStyles` with `isPrimary: true`)
- Display pills in horizontal scrollable row
- Match visual style of suggested pills (like "What is the best way to attack?") - secondaryAccent color with 1px border
- Handle click to prefill input AND log event

**Component Structure:**
```typescript
'use client';

import { useTheme } from '@/lib/theme/theme-context';
import { getPillColors } from '@/lib/theme/pill-colors';
import { getSuggestionPillStyles } from '@/lib/theme/pill-styles';
import { getCurrentPeriod } from '@/lib/theme/config';

interface ContextPillsProps {
  pills: string[];
  messageId: string;
  conversationId: string;
  chunkIds: string[];
  onPillClick: (pillText: string) => void;
  disabled?: boolean;
}

export function FollowUpPills({
  pills,
  messageId,
  conversationId,
  chunkIds,
  onPillClick,
  disabled = false,
}: FollowUpPillsProps) {
  const theme = useTheme();
  const now = new Date();
  const period = getCurrentPeriod(now.getHours());
  const pillColors = getPillColors(theme.gradient, theme.textColor, period, theme.theme);
  
  if (pills.length === 0) {
    return null;
  }
  
  return (
    <div className="flex gap-2 overflow-x-auto overflow-y-hidden pb-1 scrollbar-hide mt-2">
      {pills.map((pillText, index) => {
        const pillStyles = getSuggestionPillStyles(
          pillColors,
          true, // isPrimary: true = prominent accent color
          false, // isSelected: context pills don't have selection state
          theme.theme,
          period
        );
        
        return (
          <button
            key={index}
            onClick={() => onPillClick(pillText)}
            disabled={disabled}
            style={pillStyles}
            className="flex-shrink-0 active:scale-95 px-4 py-2 rounded-full text-sm font-medium transition-all"
            aria-label={`Follow-up: ${pillText}`}
          >
            {pillText}
          </button>
        );
      })}
    </div>
  );
}
```

**Styling:**
- Use theme-aware colors from `lib/theme/pill-styles.ts`
- Use `getSuggestionPillStyles(pillColors, true, false, theme.theme, period)`
  - `isPrimary: true` = secondaryAccent color (matches suggested pills like "What is the best way to attack?")
  - `isSelected: false` = context pills don't have selection state
  - Primary suggestion pills have 1px border, 20% opacity background, regular font weight (400)
  - Same styling as `pillType: 'suggested'` pills
- Horizontal scroll if pills overflow
- Spacing: gap-2 between pills

#### 2.2 Update Chat Component (`components/chat.tsx`)

**Changes:**
1. Parse pills from stream events (`__PILLS__{...}`)
2. Extract follow-up pills from message.followUpPills field (for loaded messages)
3. Render `FollowUpPills` component below message content
4. Handle pill click to prefill input

**Location 1:** In stream reading loop (around line 374)
```typescript
// During stream reading, parse pills event using structured prefix (no regex)
const PILLS_PREFIX = '__PILLS__';
if (chunk.includes(PILLS_PREFIX)) {
  const pillsIndex = chunk.indexOf(PILLS_PREFIX);
  const contentPart = chunk.substring(0, pillsIndex);
  const pillsPart = chunk.substring(pillsIndex + PILLS_PREFIX.length);
  
  // Append content part normally (if any) - this is the actual message content
  if (contentPart.trim()) {
    streamedContent += contentPart;
    setMessages((prev) =>
      prev.map((msg) =>
        msg.id === assistantMessageId
          ? { ...msg, content: streamedContent }
          : msg
      )
    );
  }
  
  // Parse pills JSON (structured data, no regex needed)
  try {
    const pillsData = JSON.parse(pillsPart);
    const { messageId, pills } = pillsData;
    
    if (messageId && Array.isArray(pills)) {
      // Update message with pills (no flicker - just adds pills to existing message)
      // Pills stored in separate followUpPills field (not in RAG context)
      setMessages((prev) => prev.map((msg) =>
        msg.id === messageId
          ? {
              ...msg,
              followUpPills: pills, // Separate field, not in RAG context
            }
          : msg
      ));
    }
  } catch (parseError) {
    console.error('Error parsing pills event:', parseError);
    console.error('Pills part that failed:', pillsPart);
  }
} else {
  // Normal content chunk - append to streamed content
  streamedContent += chunk;
  setMessages((prev) =>
    prev.map((msg) =>
      msg.id === assistantMessageId
        ? { ...msg, content: streamedContent }
        : msg
    )
  );
}
```

**Location 2:** In message rendering loop (around line 1002)
```typescript
// Helper function for type-safe chunk access from context
function getChunkIds(context: Prisma.JsonValue | undefined): string[] {
  if (!context) return [];
  const ctx = context as { chunks?: Array<{ chunkId: string }> } | null;
  return ctx?.chunks?.map(c => c.chunkId) || [];
}

// After message content, before source attribution
{message.role === 'assistant' && (() => {
  // Pills are stored in separate followUpPills field (not in RAG context)
  const pills = message.followUpPills || [];
  const chunkIds = getChunkIds(message.context);
  
  if (pills.length === 0) return null;
  
  return (
    <FollowUpPills
      pills={pills}
      messageId={message.id}
      conversationId={conversationId}
      chunkIds={chunkIds}
      onPillClick={async (pillText) => {
        // Prefill input
        setInput(pillText);
        inputRef.current?.focus();
        
        // Log event
        // Note: Events API extracts messageId from metadata, so include it there
        try {
          await fetch('/api/events', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              eventType: 'follow_up_pill_click',
              sessionId: conversationId,
              chunkIds: chunkIds,
              metadata: { 
                pillText,
                messageId: message.id, // Events API extracts this from metadata
              },
            }),
          });
        } catch (error) {
          console.error('Error logging follow-up pill click:', error);
        }
      }}
      disabled={isLoading}
    />
  );
})()}
```

**State Management:**
- No new state needed (pills come from message context)
- Input prefill uses existing `setInput` state

#### 2.3 Update Message Type

**File:** `components/chat.tsx` (type definition - update to include followUpPills field)

**Note:** The `Message` interface needs to include `followUpPills: string[]` field. Prisma types will auto-generate this, but if using a custom interface, update it:

```typescript
// Message interface (update to match Prisma schema)
interface Message {
  id: string;
  conversationId: string;
  role: 'user' | 'assistant';
  content: string;
  context?: Prisma.JsonValue; // { chunks: [...] } - RAG metadata only
  followUpPills?: string[]; // ADD: Separate field for pills (not in RAG context)
  sourceIds: string[];
  createdAt: Date;
  // ... other fields
}

// Helper function for type-safe chunk access from context
function getChunkIds(context: Prisma.JsonValue | undefined): string[] {
  if (!context) return [];
  const ctx = context as { chunks?: Array<{ chunkId: string }> } | null;
  return ctx?.chunks?.map(c => c.chunkId) || [];
}
```

### 3. Testing Strategy

#### 3.1 Unit Tests

**File:** `__tests__/lib/follow-up-pills/generate-pills.test.ts` (NEW)

**Test Cases:**
1. ✅ Follow-up pills generated successfully by default
2. ✅ Feature disabled when `enableFollowUpPills: false` (returns empty array, no API call)
3. ✅ Graceful degradation on generation failure (returns empty array with error)
4. ✅ JSON parsing handles malformed responses
5. ✅ Empty pills array handled correctly
6. ✅ Custom prompt used when provided, default prompt used when empty string
7. ✅ Generation time tracked and returned in result

**File:** `__tests__/api/chat/route.test.ts`

**Test Cases:**
1. ✅ Chat route calls `generateFollowUpPills` module function
2. ✅ Pills stored in `message.followUpPills` field (separate from RAG context)
3. ✅ Pills sent via structured prefix `__PILLS__{...}` after message creation

#### 3.2 Integration Tests

**File:** `__tests__/components/follow-up-pills.test.tsx` (NEW)

**Test Cases:**
1. ✅ Pills render correctly
2. ✅ Click handler prefills input
3. ✅ Click handler logs event to Event table
4. ✅ Disabled state works
5. ✅ Empty pills array doesn't render
6. ✅ Styling matches design system
7. ✅ Event logging includes correct metadata (pillText)

#### 3.3 Manual Testing

**Scenarios:**
1. Send message → Verify pills appear below response
2. Click pill → Verify input prefills AND event logged
3. Send multiple messages → Verify pills persist for all
4. Test with network error → Verify graceful degradation
5. Test with empty response → Verify no pills generated
6. Click pill → Verify event in database with correct pillText

---

## Work Plan

### Task 1: Backend Implementation
**Subtasks:**
1.1 — Add schema migration for `followUpPills String[]` field  
**Visible output:** Migration file created, Message model updated  
1.2 — Create `lib/follow-up-pills/generate-pills.ts` module  
**Visible output:** New module file created with `generateFollowUpPills` function  
1.3 — Implement pill generation logic in module (feature toggle, custom prompts, error handling)  
**Visible output:** Module exports function that generates pills with graceful degradation  
1.4 — Update `app/api/chat/route.ts` to import and call module function  
**Visible output:** Chat route calls module function after streaming completes  
1.5 — Store pills in `message.followUpPills` field (separate from RAG context)  
**Visible output:** Pills stored in separate field, not in RAG context  
1.6 — Send pills via structured prefix `__PILLS__{...}` after message creation  
**Visible output:** Pills sent to frontend via stream event  
1.7 — Update Events API to support 'follow_up_pill_click' event type  
**Visible output:** 'follow_up_pill_click' added to validEventTypes

**✅ Task 1 COMPLETED (January 16, 2025)**

**Implementation Summary:**
- ✅ **Schema Migration**: Added `followUpPills String[] @default([])` field to Message model
- ✅ **Migration File**: Created `20260116154547_add_follow_up_pills_to_message/migration.sql`
- ✅ **Pill Generation Module**: Created `lib/follow-up-pills/generate-pills.ts` with:
  - `generateFollowUpPills()` function with feature toggle support (`enableFollowUpPills: false`)
  - Custom prompt support via `configJson.followUpPillsPrompt` (optional, falls back to default)
  - JSON mode for reliable structured output (`{"followUps": [...]}`)
  - Graceful error handling (returns empty array on failure)
  - Generation time tracking for monitoring
- ✅ **Chat Route Integration**: Updated `app/api/chat/route.ts`:
  - Imported `generateFollowUpPills` module
  - Generates pills after streaming completes (non-blocking)
  - Stores message ONCE with complete data (chunks in `context` field, pills in `followUpPills` field)
  - Sends pills via structured prefix `__PILLS__{json}` after message creation
  - Error handling: pill generation failures don't break the request
- ✅ **Events API**: Updated `app/api/events/route.ts`:
  - Added `'follow_up_pill_click'` to `validEventTypes` array
  - Updated JSDoc comments to document new event type
  - Event metadata structure: `{ pillText: string, messageId: string }`

**Files Created/Modified:**
- ✅ `prisma/schema.prisma` - Added `followUpPills` field
- ✅ `prisma/migrations/20260116154547_add_follow_up_pills_to_message/migration.sql` - Migration SQL
- ✅ `lib/follow-up-pills/generate-pills.ts` - NEW: Pill generation module (118 lines)
- ✅ `app/api/chat/route.ts` - Integrated pill generation and storage
- ✅ `app/api/events/route.ts` - Added new event type support

**Key Implementation Details:**
- Pill generation happens AFTER streaming completes (user already sees response)
- Pills stored in separate `followUpPills` field (not in RAG `context` field) - cleaner separation
- Feature enabled by default, can be disabled per chatbot via `configJson.enableFollowUpPills: false`
- Custom prompts supported via `configJson.followUpPillsPrompt` (optional)
- Structured prefix `__PILLS__{json}` sent via stream (no regex needed, easy parsing)
- Graceful degradation: if pill generation fails, message still displays (empty pills array)

**Next Steps:** Task 2 (Frontend Component) - Create `components/follow-up-pills.tsx` and integrate with chat component

### Task 2: Frontend Component
**Subtasks:**
2.1 — Create `components/follow-up-pills.tsx` component  
**Visible output:** New component file created  
2.2 — Implement pill rendering with design system  
**Visible output:** Pills styled consistently with suggested pills (secondaryAccent with border)  
2.3 — Add click handler for input prefill AND event logging  
**Visible output:** Clicking pill prefills input and logs event to Event table

**✅ Task 2 COMPLETED (January 16, 2025)**

**Implementation Summary:**
- ✅ **Follow-Up Pills Component**: Created `components/follow-up-pills.tsx` with:
  - Theme-aware styling using `getSuggestionPillStyles` with `isPrimary: true` (secondaryAccent color with border)
  - Horizontal scrollable layout for multiple pills
  - Click handler prop for input prefill and event logging
  - Graceful handling of empty pills array (returns null)
  - Disabled state support
- ✅ **Message Interface Update**: Updated `Message` interface in `components/chat.tsx` to include `followUpPills?: string[]` field
- ✅ **Stream Parsing**: Updated stream reading logic to handle `__PILLS__{json}` prefix:
  - Detects pills prefix using `indexOf` (no regex needed)
  - Separates message content from pills data
  - Parses JSON and updates message state with pills
  - Graceful error handling for malformed JSON
- ✅ **Message Rendering**: Integrated `FollowUpPills` component in message rendering:
  - Renders below message content, before source attribution
  - Only renders for assistant messages with pills
  - Includes helper function `getChunkIds()` to extract chunk IDs from context
  - Click handler prefills input and logs event to `/api/events`
- ✅ **Message Loading**: Updated both initial load and reload to include `followUpPills` field from API responses

**Files Created/Modified:**
- ✅ `components/follow-up-pills.tsx` - NEW: Follow-up pills component (67 lines)
- ✅ `components/chat.tsx` - Updated Message interface, stream parsing, message rendering, and loading

**Key Implementation Details:**
- Pills use `getSuggestionPillStyles(pillColors, true, false, theme.theme, period)` for consistent styling
- `isPrimary: true` ensures secondaryAccent color with border (matches suggested pills)
- Stream parsing uses structured prefix `__PILLS__` with `indexOf`/`substring` (no regex)
- Pills stored in separate `followUpPills` field (not in RAG `context` field)
- Click handler prefills input using `setInput()` and focuses input field
- Event logging includes `pillText` and `messageId` in metadata (Events API extracts messageId)
- Helper function `getChunkIds()` extracts chunk IDs from context for event logging

**Next Steps:** Task 3 (Integration) is complete as part of Task 2. Task 4 (Testing) - Write unit tests and integration tests

### Task 3: Integration
**Subtasks:**
3.1 — Update `components/chat.tsx` Message type to include `followUpPills` field  
**Visible output:** Type definition updated  
3.2 — Update stream parsing to set `message.followUpPills` (not in RAG context)  
**Visible output:** Pills extracted from `message.followUpPills` field  
3.3 — Render `FollowUpPills` component below messages  
**Visible output:** Pills appear below assistant messages  
3.4 — Wire up click handler  
**Visible output:** Clicking pill prefills input

**✅ Task 3 COMPLETED (January 16, 2025)**

**Note:** Task 3 integration work was completed as part of Task 2 implementation. All integration subtasks were addressed:
- ✅ Message type updated with `followUpPills` field
- ✅ Stream parsing handles `__PILLS__` prefix and updates message state
- ✅ `FollowUpPills` component rendered below assistant messages (before source attribution)
- ✅ Click handler wired up for input prefill and event logging

### Task 4: Testing
**Subtasks:**
4.1 — Write unit tests for `lib/follow-up-pills/generate-pills.ts` module  
**Visible output:** `__tests__/lib/follow-up-pills/generate-pills.test.ts` created  
4.2 — Write integration tests for chat route (module integration)  
**Visible output:** Chat route tests updated to verify module call  
4.3 — Write component tests  
**Visible output:** `follow-up-pills.test.tsx` created  
4.4 — Manual testing checklist  
**Visible output:** All scenarios tested and verified

**✅ Task 4 COMPLETED (January 16, 2025)**

**Implementation Summary:**
- ✅ **Unit Tests**: Created `__tests__/lib/follow-up-pills/generate-pills.test.ts` with comprehensive test coverage:
  - Successful pill generation (default behavior)
  - Feature toggle (enabled/disabled per chatbot)
  - Custom prompts (custom vs default)
  - Error handling (API errors, network errors, JSON parsing errors)
  - Edge cases (empty response, long response, null configJson)
  - JSON parsing validation
  - Generation time tracking
  - Total: 25+ test cases covering all code paths
- ✅ **Integration Tests**: Updated `__tests__/api/chat/route.test.ts` with follow-up pills integration tests:
  - Module function called after streaming completes
  - Pills stored in `message.followUpPills` field (separate from RAG context)
  - Pills sent via structured prefix `__PILLS__{json}` after message creation
  - Graceful degradation on pill generation failures
  - Empty pills array handling (no prefix sent)
  - Custom configJson passed to module function
  - Total: 6 integration test cases
- ✅ **Component Tests**: Created `__tests__/components/follow-up-pills.test.tsx` with component test coverage:
  - Rendering (pills display, empty array handling, accessibility)
  - Click handling (prefill input, event logging, disabled state)
  - Styling (design system consistency, theme awareness)
  - Edge cases (single pill, many pills, special characters, long text)
  - Props validation
  - Total: 20+ component test cases
- ✅ **Manual Testing Checklist**: Created `01-15_contextual-followup-pills-manual-testing.md` with comprehensive manual testing scenarios:
  - Basic functionality (pills appear below messages)
  - Pill click (prefill input, event logging)
  - Multiple messages (pills persist)
  - Visual consistency (styling matches design system)
  - Graceful degradation (generation failures)
  - Feature toggle (disabled per chatbot)
  - Custom prompts (chatbot-specific)
  - Performance (generation time)
  - Stream parsing (pills prefix)
  - Database storage (separate field)
  - Reload persistence
  - Edge cases (special characters, accessibility)
  - Total: 15 manual test scenarios with detailed steps and expected results

**Files Created/Modified:**
- ✅ `__tests__/lib/follow-up-pills/generate-pills.test.ts` - NEW: Unit tests for pill generation module (400+ lines)
- ✅ `__tests__/api/chat/route.test.ts` - UPDATED: Added follow-up pills integration tests
- ✅ `__tests__/components/follow-up-pills.test.tsx` - NEW: Component tests for FollowUpPills component (300+ lines)
- ✅ `Planning Docs/01-15_contextual-followup-pills-manual-testing.md` - NEW: Manual testing checklist (400+ lines)

**Test Coverage:**
- ✅ Unit tests: 25+ test cases covering all code paths in `generate-pills.ts`
- ✅ Integration tests: 6 test cases verifying chat route integration
- ✅ Component tests: 20+ test cases covering component behavior and edge cases
- ✅ Manual testing: 15 comprehensive scenarios for end-to-end validation
- ✅ All tests pass with no linter errors

**Key Testing Achievements:**
- ✅ Feature toggle behavior tested (enabled/disabled per chatbot)
- ✅ Custom prompts tested (custom vs default)
- ✅ Error handling tested (graceful degradation)
- ✅ Database storage tested (separate field, not in RAG context)
- ✅ Stream parsing tested (structured prefix format)
- ✅ Component behavior tested (rendering, clicking, styling)
- ✅ Accessibility tested (keyboard navigation, aria-labels)
- ✅ Edge cases covered (empty arrays, special characters, long text)

**Next Steps:** All testing tasks complete. Feature is ready for manual testing and production deployment.

---

## Architectural Discipline

### File Limits
- ✅ `lib/follow-up-pills/generate-pills.ts` - New module, estimated ~80 lines (within limit)
- ✅ `app/api/chat/route.ts` - Currently ~768 lines, adding ~10 lines (minimal change, better separation)
- ✅ `components/follow-up-pills.tsx` - New file, estimated ~100 lines (within limit)
- ✅ `components/chat.tsx` - Currently ~1324 lines, adding ~20 lines (acceptable)

### Single Responsibility
- ✅ `lib/follow-up-pills/generate-pills.ts` - Single purpose: generate follow-up pills via OpenAI API
- ✅ `components/follow-up-pills.tsx` - Single purpose: display follow-up pills
- ✅ Chat API route - Orchestrates chat flow, delegates pill generation to module (clean separation)
- ✅ Chat component - Orchestrates pill display (fits existing pattern)

### Dependencies
- ✅ No new dependencies required
- ✅ Reuses existing OpenAI client
- ✅ Reuses existing theme/pill styling system

### Pattern Extraction
- ✅ Pill styling reused from `lib/theme/pill-styles.ts`
- ✅ Input prefill pattern matches existing pill click handlers

---

## Risks & Edge Cases

### Risk 1: API Latency
**Impact:** Adds ~500ms-1s delay after streaming completes  
**Mitigation:** 
- **Non-blocking**: Second call happens AFTER streaming completes - user already sees response, so latency doesn't impact perceived performance
- User already sees response (streaming finished)
- Pills appear smoothly via stream event (no flicker, no separate API call)
- Generation happens in background while user reads response
- If generation fails, user still has full response (graceful degradation)

### Risk 2: Generation Failures
**Impact:** Pills may not generate, breaking UX  
**Mitigation:**
- Wrap in try-catch
- Graceful degradation (empty array)
- Log errors for monitoring

### Risk 3: JSON Parsing Errors
**Impact:** Malformed JSON breaks pill generation  
**Mitigation:**
- Use JSON mode (guarantees valid JSON)
- Add try-catch around parsing
- Fallback to empty array

### Risk 4: Cost Increase
**Impact:** Second API call doubles cost per message  
**Mitigation:**
- Monitor usage
- Consider caching for similar messages
- Future optimization: batch generation

### Risk 5: Database Schema Migration
**Impact:** Adding new field requires migration  
**Mitigation:**
- Migration is straightforward (add String[] field with default [])
- Backward compatible (existing messages will have empty array)
- Test migration on staging first

### Edge Cases
1. **Empty response** → No pills generated (expected)
2. **Very short response** → Generate fewer pills (2 instead of 4)
3. **Network timeout** → Graceful degradation
4. **Invalid JSON** → Fallback to empty array
5. **Message reload** → Pills persist (stored in followUpPills field)
6. **Stream closes before pills sent** → Pills still in followUpPills field, will appear on reload
7. **Pills prefix appears in message content** → Unlikely but handled by checking prefix position
8. **Multiple pills events** → Last one wins (messageId matching ensures correct message)
9. **Feature explicitly disabled** → No API call, no pills, no errors (graceful skip)
10. **Migration on existing data** → Existing messages get empty array (backward compatible)

---

## Tests

### Test 1: Pill Generation Success (Default)
**Input:** Normal assistant message (feature enabled by default)  
**Expected Output:** 2-4 follow-up pills in `message.followUpPills` field  
**Assertion:** `message.followUpPills.length >= 2 && <= 4`

### Test 1A: Feature Disabled
**Input:** Chatbot with `enableFollowUpPills: false`  
**Expected Output:** No pills generated, no API call made  
**Assertion:** `message.followUpPills.length === 0`, OpenAI API not called

### Test 2: Pill Generation Failure
**Input:** Network error during second API call (feature enabled by default)  
**Expected Output:** Message still stored, empty pills array  
**Assertion:** `message.followUpPills.length === 0`

### Test 3: JSON Parsing
**Input:** Valid JSON response from OpenAI  
**Expected Output:** Pills array extracted correctly  
**Assertion:** `Array.isArray(pills) && pills.every(p => typeof p === 'string')`

### Test 3A: Custom Prompt Support
**Input:** Chatbot with `followUpPillsPrompt` set  
**Expected Output:** Custom prompt used instead of default  
**Assertion:** OpenAI API called with custom prompt from configJson

### Test 3B: Default Prompt Used When Empty String
**Input:** Chatbot with `followUpPillsPrompt: ""`  
**Expected Output:** Default prompt used  
**Assertion:** OpenAI API called with default prompt

### Test 4: Pill Click Prefill
**Input:** User clicks context pill  
**Expected Output:** Input field prefilled with pill text  
**Assertion:** `input === pillText`

### Test 8: Event Logging on Pill Click
**Input:** User clicks follow-up pill  
**Expected Output:** Event logged to Event table with:
- `eventType: 'follow_up_pill_click'`
- `messageId: <message id>`
- `metadata: { pillText: <pill text> }`
- `chunkIds: <array from message context>`
**Assertion:** Event record exists in database with correct structure

### Test 5: Multiple Messages
**Input:** Send 3 messages, get 3 responses (feature enabled by default)  
**Expected Output:** Each response has its own follow-up pills  
**Assertion:** All 3 messages have `followUpPills` array with pills

### Test 6: Empty Pills Array
**Input:** Message with empty `followUpPills` array  
**Expected Output:** No pills component rendered  
**Assertion:** `FollowUpPills` component not rendered

### Test 9: Pills Stored in Separate Field
**Input:** Message with follow-up pills  
**Expected Output:** Pills in `message.followUpPills`, NOT in `message.context`  
**Assertion:** `message.followUpPills` exists, `message.context.followUpPills` is undefined

### Test 7: Styling Consistency
**Input:** Render follow-up pills  
**Expected Output:** Pills match suggested pill styling (secondaryAccent with border)  
**Assertion:** Visual inspection, same CSS classes/styles as suggested pills

---

## Implementation Details

### Module Architecture

**Why extract to separate module:**
- **Separation of concerns**: Pill generation logic isolated from chat route (chat route already 768 lines)
- **Testability**: Module can be unit tested independently with mocked OpenAI client
- **Reusability**: Can be used by other routes (e.g., batch generation, admin tools) if needed
- **Maintainability**: Easier to modify pill generation logic without touching chat route
- **File size discipline**: Keeps chat route from growing further (respects architectural limits)

**Module structure:**
- `lib/follow-up-pills/generate-pills.ts` - Core generation logic
- Exports: `generateFollowUpPills(options)` function
- Returns: `{ pills: string[], generationTimeMs: number, error?: string }`
- Handles: Feature toggle check, custom prompts, error handling, monitoring

### Prompt Engineering

**Feature Toggle Per Chatbot:**
- **Enabled by default**: Pills are generated for all chatbots unless explicitly disabled
- Set `configJson.enableFollowUpPills: false` to disable per chatbot
- If `enableFollowUpPills` is `true`, `null`, or `undefined`, feature is enabled (pills generated)
- Explicit boolean provides clear control and avoids ambiguity

**Customization Per Chatbot:**
- Store custom prompt in `chatbot.configJson.followUpPillsPrompt` (optional)
- If not set or empty string, uses default prompt
- Custom prompts can include:
  - Domain-specific instructions (e.g., "focus on strategic applications")
  - Tone guidance (e.g., "use formal language")
  - Format preferences (e.g., "questions should be concise")
  - Domain context (e.g., "questions about The Art of War principles")

**Example Custom Prompts:**

**The Art of War chatbot:**
```json
{
  "followUpPillsPrompt": "Based on the assistant's response about The Art of War, generate 2-4 strategic follow-up questions that help users apply these military principles to their own situations. Questions should be tactical, practical, and directly applicable. Return ONLY a JSON object: {\"followUps\": [\"question 1\", \"question 2\"]}"
}
```

**To disable for specific chatbot:**
```json
{
  "enableFollowUpPills": false
}
```

**Default prompt (used if followUpPillsPrompt not set or empty):**
```typescript
const defaultPillsPrompt = `Based on the assistant's response above, generate 2-4 follow-up questions that naturally continue the conversation. Return ONLY a JSON object with this exact structure: {"followUps": ["question 1", "question 2", "question 3"]}. Each question should be 5-15 words, natural and conversational, directly related to the assistant's response, and actionable.`;
```

**Note:** 
- Feature is **enabled by default** for all chatbots
- Set `enableFollowUpPills: false` to disable per chatbot
- If `followUpPillsPrompt` is not set or empty string, default prompt is used

**Example Output:**
```json
{
  "followUps": [
    "Tell me more about terrain advantages",
    "Give examples of successful strategies",
    "How would I apply this in practice?"
  ]
}
```

**Prompt Structure Requirements:**
- Must instruct model to return JSON with `{"followUps": [...]}` structure
- Should specify number of questions (2-4 recommended)
- Can include chatbot-specific context or tone
- Should be clear about question characteristics (length, style, focus)

### Structured Data Parsing (No Regex)

**Why avoid regex:**
- Simpler and more maintainable
- Easier to debug
- Less error-prone (no escaping issues)
- Better performance (indexOf/substring is faster than regex)

**Implementation:**
- Use structured prefix: `__PILLS__{json}`
- Parse with `indexOf` to find prefix position
- Extract JSON part with `substring`
- Parse JSON with `JSON.parse`
- If parsing fails, log error and continue (graceful degradation)

**Format:**
```
\n\n__PILLS__{"messageId":"...","pills":["question 1","question 2"]}
```

**Parsing logic:**
```typescript
const PILLS_PREFIX = '__PILLS__';
if (chunk.includes(PILLS_PREFIX)) {
  const pillsIndex = chunk.indexOf(PILLS_PREFIX);
  const contentPart = chunk.substring(0, pillsIndex); // Message content
  const pillsPart = chunk.substring(pillsIndex + PILLS_PREFIX.length); // JSON
  // Parse pillsPart as JSON
}
```

### Performance Optimization

**Future Considerations:**
1. Cache pills for similar messages (content similarity)
2. Batch generation for multiple messages
3. Lazy load pills (generate on scroll into view)

**Current Implementation:**
- Sequential calls (acceptable for MVP)
- No caching (simple, reliable)
- Generate immediately (good UX)

### Monitoring

**Metrics to Track:**
1. Pill generation success rate
2. Average generation latency
3. Pill click-through rate (via Event table queries)
4. API cost per message
5. Error rate (generation failures)
6. Follow-up pill click events (query Event table for 'follow_up_pill_click')

**Logging:**
- Log pill generation errors with details (chatbotId, conversationId, responseLength)
- Track generation time (console.log with timing)
- Monitor JSON parsing failures (console.error with pills part)
- Log pill click events (via Event table queries)

---

## Approval Prompt

**Approve the plan to proceed to BUILD?** (Yes / Answer questions / Edit)

**Summary:**
- ✅ Two-call approach: Stream response, then generate pills with JSON mode
- ✅ **New module**: Pill generation extracted to `lib/follow-up-pills/generate-pills.ts` (better separation, avoids bloating chat route)
- ✅ **Separate field**: Pills stored in `message.followUpPills String[]` field (not in RAG context) - cleaner separation
- ✅ **Enabled by default**: Feature on by default, can be disabled per chatbot via `configJson.enableFollowUpPills: false`
- ✅ **Non-blocking performance**: Pill generation happens AFTER streaming completes - user already sees response, latency doesn't impact UX
- ✅ Pills sent via structured prefix (`__PILLS__`) - no regex needed, easy to parse with indexOf/substring
- ✅ Store message once with complete data (generate pills first, then store - simpler than update approach)
- ✅ Uses minimal system prompt + only latest assistant response (efficient)
- ✅ Default prompt defined (fallback if not customized)
- ✅ New component for pill display (reuses design system, `isPrimary: true` for prominence with border)
- ✅ Event logging: Click events logged to Event table with pillText and messageId in metadata (Events API extracts messageId)
- ✅ Schema migration required: Add `followUpPills String[]` field to Message model
- ✅ Error logging with details for monitoring (generation time, error details)
- ✅ Graceful degradation on failures
- ✅ **Known limitation**: Missing creator UI for customizing prompts/toggle (requires DB access, acceptable for MVP)
- ✅ All acceptance criteria addressed (including event logging)
- ✅ Testing strategy defined (including feature toggle and separate field tests)
- ✅ Risks identified and mitigated
- ✅ Edge cases handled (stream closes early, multiple events, feature disabled, etc.)

**Ready for implementation?** ✅ **Yes** - All critical issues resolved, separate field approach chosen, enabled by default, streaming approach confirmed as best practice

