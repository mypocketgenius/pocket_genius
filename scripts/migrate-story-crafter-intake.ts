// scripts/migrate-story-crafter-intake.ts
// One-time migration: updates Story Crafter from 7 intake questions to 5
// Run with: npx tsx scripts/migrate-story-crafter-intake.ts

import { Prisma } from '@prisma/client';
import { prisma } from '../lib/prisma';

const OWNER_USER_ID = "cmj256oei0000chlu8qmj8fs0";
const CHATBOT_ID = "story_crafter";
const VERSION_ID = "story_crafter_v1";

const OLD_QUESTION_IDS = ["sc_user_need", "sc_why", "sc_acceptance_criteria", "sc_complexity"];

const systemPrompt = `You are Story Crafter, an expert at writing INVEST-compliant user stories for Scrum teams.

## Your Knowledge
You have access to best practices from Mike Cohn, Roman Pichler, and the Scrum Guide. Use the retrieved context to ground your recommendations in established practices. Always cite sources when referencing specific frameworks or techniques.

## User Context
The user has provided the following context through intake questions:
- Product/Feature Area: {intake.sc_product_area}
- User Persona: {intake.sc_persona}
- What they described: {intake.sc_description}
- Type of work: {intake.sc_story_type}
- Additional context: {intake.sc_constraints}

## Your Task
When asked to generate a user story, create a complete story with all required elements. Extract the user need ("I want to\u2026") and value statement ("so that\u2026") from the user's plain-language description \u2014 don't ask them to restate it. When asked questions about user stories or Scrum practices, respond conversationally without forcing the structured format.

## Output Format (for story generation)
When generating a user story, format your response as follows:

## User Story
**As a** [specific persona - use the provided persona, make it concrete and relatable]
**I want to** [need - extracted from the user's description]
**So that** [benefit - extracted or inferred from the user's description]

## Acceptance Criteria
1. **Given** [context/precondition] **When** [action/trigger] **Then** [expected outcome]
2. **Given** [context] **When** [action] **Then** [outcome]
3. [Continue for 3-5 criteria total]

## Complexity: [XS/S/M/L/XL]
[Assess complexity based on the described scope and type of work]

## Edge Cases to Consider
- [edge case 1 - potential failure scenario or unusual input]
- [edge case 2]
- [Continue as needed]

## INVEST Compliance
- **Independent:** [Yes/No - can this be developed without depending on other stories?]
- **Negotiable:** [Yes/No - is there room for discussion on implementation details?]
- **Valuable:** [Yes/No - does it deliver clear value to the user?]
- **Estimable:** [Yes/No - can the team reasonably estimate this?]
- **Small:** [Yes/No - can it be completed in one sprint?]
- **Testable:** [Yes/No - can we verify when it's done?]

[If any INVEST criteria fail, suggest how to fix it]

---
Generated by Story Crafter | Try it free at mypocketgenius.com/story-crafter

## Guidelines
- Make the persona specific and relatable (not generic "As a user")
- The value statement should answer "why does this matter to the business or user?"
- Acceptance criteria must be testable - if you can't verify it, rewrite it
- Flag any INVEST violations with specific suggestions to fix
- If the request is too large for one story, suggest how to split it using SPIDR or workflow steps
- Assess complexity independently based on described scope \u2014 don't rely on user estimates

## What NOT to Do
- Don't prescribe implementation details (e.g., "using React" or "via REST API") unless constraints require it
- Don't create compound stories with multiple "and" conjunctions in the need
- Don't write acceptance criteria that merely restate the story narrative
- Don't ignore the user's provided context - incorporate their constraints and known criteria

## Retrieved Best Practices
{rag_context}`;

async function main() {
  console.log("Migrating Story Crafter intake questions (7 -> 5)...\n");

  // Step 1: Delete intake responses for old questions
  console.log("Step 1: Deleting intake responses for removed questions...");
  for (const qId of OLD_QUESTION_IDS) {
    const deleted = await prisma.intake_Response.deleteMany({
      where: { intakeQuestionId: qId },
    });
    console.log(`  Deleted ${deleted.count} responses for ${qId}`);
  }

  // Step 2: Delete old junction links
  console.log("\nStep 2: Deleting old Chatbot_Intake_Question links...");
  for (const qId of OLD_QUESTION_IDS) {
    const deleted = await prisma.chatbot_Intake_Question.deleteMany({
      where: { intakeQuestionId: qId, chatbotId: CHATBOT_ID },
    });
    console.log(`  Deleted ${deleted.count} link(s) for ${qId}`);
  }

  // Step 3: Delete old question records
  console.log("\nStep 3: Deleting old Intake_Question records...");
  for (const qId of OLD_QUESTION_IDS) {
    try {
      await prisma.intake_Question.delete({ where: { id: qId } });
      console.log(`  Deleted question: ${qId}`);
    } catch (e: any) {
      if (e.code === 'P2025') {
        console.log(`  Question ${qId} not found (already deleted)`);
      } else {
        throw e;
      }
    }
  }

  // Step 4: Create new question records
  console.log("\nStep 4: Creating new Intake_Question records...");
  const newQuestions = [
    {
      id: "sc_description",
      slug: "sc_description",
      questionText: "Describe what you need built and why it matters.",
      helperText: "Just explain the idea in plain language, e.g., 'Users can't filter invoices by date, so finance spends 2 hours a week doing it manually.'",
      responseType: "TEXT" as const,
      options: Prisma.JsonNull,
    },
    {
      id: "sc_story_type",
      slug: "sc_story_type",
      questionText: "What kind of work is this?",
      helperText: "This helps calibrate the story format and acceptance criteria",
      responseType: "SELECT" as const,
      options: ["New feature", "Enhancement to existing feature", "Bug fix / defect", "Tech debt / refactor"],
    },
  ];

  for (const q of newQuestions) {
    const existing = await prisma.intake_Question.findUnique({ where: { id: q.id } });
    if (!existing) {
      await prisma.intake_Question.create({
        data: { ...q, createdByUserId: OWNER_USER_ID },
      });
      console.log(`  Created question: ${q.id}`);
    } else {
      console.log(`  Question already exists: ${q.id}`);
    }
  }

  // Step 5: Create new junction links
  console.log("\nStep 5: Creating new Chatbot_Intake_Question links...");
  const newLinks = [
    { intakeQuestionId: "sc_description", displayOrder: 3, isRequired: true },
    { intakeQuestionId: "sc_story_type", displayOrder: 4, isRequired: true },
  ];

  for (const link of newLinks) {
    const existing = await prisma.chatbot_Intake_Question.findUnique({
      where: {
        intakeQuestionId_chatbotId: {
          intakeQuestionId: link.intakeQuestionId,
          chatbotId: CHATBOT_ID,
        },
      },
    });
    if (!existing) {
      await prisma.chatbot_Intake_Question.create({
        data: { chatbotId: CHATBOT_ID, ...link },
      });
      console.log(`  Linked: ${link.intakeQuestionId}`);
    } else {
      console.log(`  Link already exists: ${link.intakeQuestionId}`);
    }
  }

  // Step 6: Update existing questions
  console.log("\nStep 6: Updating existing question records...");

  await prisma.intake_Question.update({
    where: { id: "sc_product_area" },
    data: {
      questionText: "What product or feature area is this for?",
      helperText: "e.g., 'Checkout flow', 'Admin reporting dashboard', 'Onboarding emails'",
    },
  });
  console.log("  Updated sc_product_area");

  await prisma.intake_Question.update({
    where: { id: "sc_persona" },
    data: {
      questionText: "Who will use this feature?",
      helperText: "Pick the closest match \u2014 you can refine in the chat",
      options: ["Customer / end user", "Business stakeholder", "Internal ops / support", "Developer / technical user", "Other"],
    },
  });
  console.log("  Updated sc_persona");

  await prisma.intake_Question.update({
    where: { id: "sc_constraints" },
    data: {
      questionText: "Anything else the team should know?",
      helperText: "Optional \u2014 dependencies, deadlines, existing tech decisions, or known edge cases",
    },
  });
  console.log("  Updated sc_constraints");

  // Update sc_constraints junction link displayOrder from 7 to 5
  await prisma.chatbot_Intake_Question.update({
    where: {
      intakeQuestionId_chatbotId: {
        intakeQuestionId: "sc_constraints",
        chatbotId: CHATBOT_ID,
      },
    },
    data: { displayOrder: 5 },
  });
  console.log("  Updated sc_constraints displayOrder -> 5");

  // Step 7: Update Chatbot systemPrompt
  console.log("\nStep 7: Updating Chatbot systemPrompt...");
  await prisma.chatbot.update({
    where: { id: CHATBOT_ID },
    data: { systemPrompt },
  });
  console.log("  Chatbot systemPrompt updated");

  // Step 8: Update Chatbot_Version systemPrompt
  console.log("\nStep 8: Updating Chatbot_Version systemPrompt...");
  await prisma.chatbot_Version.update({
    where: { id: VERSION_ID },
    data: { systemPrompt },
  });
  console.log("  Chatbot_Version systemPrompt updated");

  // Verification
  console.log("\n--- Verification ---");
  const questions = await prisma.chatbot_Intake_Question.findMany({
    where: { chatbotId: CHATBOT_ID },
    include: { intakeQuestion: true },
    orderBy: { displayOrder: 'asc' },
  });
  console.log(`\nStory Crafter now has ${questions.length} intake questions:`);
  for (const q of questions) {
    console.log(`  ${q.displayOrder}. [${q.isRequired ? 'required' : 'optional'}] ${q.intakeQuestion.slug}: "${q.intakeQuestion.questionText}"`);
  }

  console.log("\nMigration complete!");
}

main()
  .catch((e) => {
    console.error("Error:", e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });
