// Simplified MVP Schema - Phase 1, Task 5
// Only includes tables needed for MVP functionality

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

// User model - Clerk user sync
model User {
  id        String   @id @default(cuid())
  clerkId   String   @unique
  email     String
  username  String?
  firstName String?
  lastName  String?
  createdAt DateTime @default(now())

  // Relations
  creatorMemberships Creator_User[]
  conversations      Conversation[]
  messages           Message[]
  messageFeedbacks   Message_Feedback[]
  pillUsages         Pill_Usage[]
  events             Event[]
  bookmarks          Bookmark[]
  conversationFeedbacks Conversation_Feedback[]
}

// Creator model - AI creator profile
model Creator {
  id        String   @id @default(cuid())
  name      String
  createdAt DateTime @default(now())

  // Relations
  users    Creator_User[]
  chatbots Chatbot[]
  sources  Source[]
  files    File[]
}

// Creator_User join table - Multi-user creators (for MVP, supports one user per creator)
model Creator_User {
  id        String  @id @default(cuid())
  creatorId String
  creator   Creator @relation(fields: [creatorId], references: [id], onDelete: Cascade)
  userId    String
  user      User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  role      String  @default("OWNER") // 'OWNER' | 'ADMIN' | 'MEMBER'

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([creatorId, userId])
  @@index([creatorId])
  @@index([userId])
}

// Chatbot model - Live chatbot entity
model Chatbot {
  id        String   @id @default(cuid())
  title     String
  creatorId String
  creator   Creator  @relation(fields: [creatorId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())

  // Relations
  conversations     Conversation[]
  sources           Source[]
  chunkPerformances Chunk_Performance[]
  pills             Pill[]
  pillUsages        Pill_Usage[]
  bookmarks         Bookmark[]
  ratingsAggregate  Chatbot_Ratings_Aggregate?
}

// Source model - Content sources (books, courses, etc.)
model Source {
  id        String   @id @default(cuid())
  title     String
  creatorId String
  creator   Creator  @relation(fields: [creatorId], references: [id], onDelete: Cascade)
  chatbotId String
  chatbot   Chatbot  @relation(fields: [chatbotId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())

  // Relations
  files             File[]
  chunkPerformances Chunk_Performance[]
}

// File model - Uploaded assets
model File {
  id        String   @id @default(cuid())
  sourceId  String
  source    Source   @relation(fields: [sourceId], references: [id], onDelete: Cascade)
  creatorId String
  creator   Creator  @relation(fields: [creatorId], references: [id], onDelete: Cascade)
  fileName  String
  fileUrl   String
  fileSize  Int
  status    String   @default("PENDING") // 'PENDING' | 'PROCESSING' | 'READY' | 'ERROR'
  createdAt DateTime @default(now())

  @@index([sourceId])
  @@index([creatorId])
}

// Conversation model - Chat sessions
model Conversation {
  id           String   @id @default(cuid())
  chatbotId    String
  chatbot      Chatbot  @relation(fields: [chatbotId], references: [id], onDelete: Cascade)
  userId       String?
  user         User?    @relation(fields: [userId], references: [id], onDelete: Cascade)
  status       String   @default("active") // 'active' | 'completed'
  messageCount Int      @default(0)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // Relations
  messages Message[]
  conversationFeedback Conversation_Feedback?

  @@index([chatbotId, status])
  @@index([userId])
}

// Message model - Individual messages in conversations
model Message {
  id             String       @id @default(cuid())
  conversationId String
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  userId         String?
  user           User?        @relation(fields: [userId], references: [id], onDelete: Cascade)
  role           String // 'user' | 'assistant'
  content        String
  context        Json? // { chunks: [{ chunkId, sourceId, text, page?, section? }] }
  sourceIds      String[]     @default([]) // Extracted from context.chunks for easier querying
  createdAt      DateTime     @default(now())

  // Relations
  messageFeedbacks Message_Feedback[]
  bookmarks        Bookmark[]

  @@index([conversationId])
  @@index([sourceIds])
  @@index([userId])
}

// Message_Feedback model - Thumbs up/down feedback, "need more" feedback, and copy feedback
// Phase 3.3: Added needsMore array and specificSituation for "need more" feedback
// Phase 3.4: Added copyUsage and copyContext for copy feedback tracking
model Message_Feedback {
  id                String   @id @default(cuid())
  messageId         String
  message           Message  @relation(fields: [messageId], references: [id], onDelete: Cascade)
  userId            String?
  user              User?    @relation(fields: [userId], references: [id], onDelete: Cascade)
  feedbackType      String // 'helpful' | 'not_helpful' | 'need_more' | 'copy'
  // Phase 3.3: "Need More" feedback fields
  needsMore         String[] @default([]) // ['scripts', 'examples', 'steps', 'case_studies'] - format preferences user needs
  specificSituation String? // Free text describing user's specific situation (optional)
  // Phase 3.4: Copy feedback fields
  copyUsage         String? // 'reference' | 'use_now' | 'share_team' | 'adapt' - how user will use copied content
  copyContext       String? // Free text context (required if copyUsage is 'adapt')
  createdAt         DateTime @default(now())

  @@index([messageId])
  @@index([userId])
}

// Chunk_Performance model - Basic counters for chunk usage and feedback
model Chunk_Performance {
  id        String  @id @default(cuid())
  chunkId   String
  sourceId  String
  source    Source  @relation(fields: [sourceId], references: [id], onDelete: Cascade)
  chatbotId String
  chatbot   Chatbot @relation(fields: [chatbotId], references: [id], onDelete: Cascade)

  // Counters
  timesUsed       Int @default(0)
  helpfulCount    Int @default(0)
  notHelpfulCount Int @default(0)

  // Phase 3.3: "Need more" feedback counters - track what format users need more of
  needsScriptsCount   Int @default(0) // Count of users needing scripts/exact words
  needsExamplesCount  Int @default(0) // Count of users needing more examples
  needsStepsCount     Int @default(0) // Count of users needing step-by-step instructions
  needsCaseStudyCount Int @default(0) // Count of users needing case studies/real scenarios

  // Phase 3.4: Copy feedback counter
  copyToUseNowCount Int @default(0) // Count of users copying content to use immediately

  // Computed satisfaction rate (updated on each feedback)
  satisfactionRate Float @default(0)

  // Cached chunk text for dashboard display (populated on first use from Pinecone)
  chunkText     String?
  chunkMetadata Json? // { page, section, sourceTitle }

  // Time period
  month Int
  year  Int

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([chunkId, chatbotId, month, year])
  @@index([chatbotId, month, year, satisfactionRate])
  @@index([chatbotId, month, year, timesUsed])
  @@index([sourceId])
}

// Pill model - Feedback, expansion, and suggested question pills
// Phase 1: Feedback UX System Update
model Pill {
  id          String   @id @default(cuid())
  chatbotId   String?  // NULL for system pills
  chatbot     Chatbot? @relation(fields: [chatbotId], references: [id], onDelete: Cascade)
  pillType    String   // 'feedback' | 'expansion' | 'suggested'
  label       String   // Display text
  prefillText String   // Input prefill text
  displayOrder Int     @default(0)
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  pillUsages       Pill_Usage[] @relation("PillUsage")
  pairedPillUsages Pill_Usage[] @relation("PillPairing")
  
  @@index([chatbotId])
  @@index([pillType])
}

// Pill_Usage model - Tracks when pills are used
// Phase 1: Feedback UX System Update
model Pill_Usage {
  id              String   @id @default(cuid())
  pillId          String
  pill            Pill     @relation("PillUsage", fields: [pillId], references: [id], onDelete: Cascade)
  sessionId       String?  // Conversation ID
  userId          String?
  user            User?    @relation(fields: [userId], references: [id], onDelete: Cascade)
  chatbotId       String
  chatbot         Chatbot @relation(fields: [chatbotId], references: [id], onDelete: Cascade)
  sourceChunkIds  String[] @default([])
  prefillText     String
  sentText        String
  wasModified     Boolean  @default(false)
  pairedWithPillId String?
  pairedWithPill  Pill?    @relation("PillPairing", fields: [pairedWithPillId], references: [id])
  timestamp       DateTime @default(now())

  @@index([pillId])
  @@index([sessionId])
  @@index([userId])
  @@index([chatbotId])
}

// Event model - General event logging (copy, bookmark, conversation patterns, etc.)
// Phase 1: Feedback UX System Update
model Event {
  id          String   @id @default(cuid())
  sessionId   String?  // Conversation ID
  userId      String?
  user        User?    @relation(fields: [userId], references: [id], onDelete: Cascade)
  eventType   String   // 'copy' | 'bookmark' | 'conversation_pattern' | 'expansion_followup' | 'gap_submission'
  chunkIds    String[] @default([])
  metadata    Json?    // Event-specific data
  timestamp   DateTime @default(now())

  @@index([sessionId])
  @@index([userId])
  @@index([eventType])
  @@index([timestamp])
}

// Bookmark model - User-saved messages
// Phase 1: Feedback UX System Update
model Bookmark {
  id          String   @id @default(cuid())
  messageId   String
  message     Message  @relation(fields: [messageId], references: [id], onDelete: Cascade)
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  chatbotId   String
  chatbot     Chatbot  @relation(fields: [chatbotId], references: [id], onDelete: Cascade)
  chunkIds    String[] @default([]) // Chunks from message context
  notes       String?  // Optional user notes
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@unique([messageId, userId]) // One bookmark per message per user
  @@index([userId])
  @@index([chatbotId])
  @@index([createdAt])
}

// Conversation_Feedback model - Chat rating and follow-up questions
// Phase 1: Feedback UX System Update (Phase 3.5: End-of-conversation survey)
model Conversation_Feedback {
  id           String   @id @default(cuid())
  conversationId String
  conversation  Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  userId       String?
  user         User?    @relation(fields: [userId], references: [id], onDelete: Cascade)
  rating       Int?     // 1-5 star rating
  userGoal     String?  // What were you trying to accomplish?
  goalAchieved String?  // Yes/Partially/No
  stillNeed    String?  // What's still missing?
  timeSaved    String?  // How much time did this save you? (e.g., "5 minutes", "30 minutes", "1 hour", "2+ hours", "Not applicable")
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@unique([conversationId]) // One rating per conversation
  @@index([userId])
  @@index([rating])
}

// Chatbot_Ratings_Aggregate model - Aggregated ratings for chatbots
// Phase 1: Feedback UX System Update
model Chatbot_Ratings_Aggregate {
  id                String   @id @default(cuid())
  chatbotId         String   @unique
  chatbot           Chatbot  @relation(fields: [chatbotId], references: [id], onDelete: Cascade)
  averageRating     Decimal  @db.Decimal(3, 2)
  ratingCount       Int      @default(0)
  ratingDistribution Json?   // {"1": 5, "2": 10, "3": 25, ...}
  updatedAt         DateTime @updatedAt
}
